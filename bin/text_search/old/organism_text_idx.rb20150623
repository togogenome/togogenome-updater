#!/usr/bin/env ruby

require 'json'
require 'fileutils'

ISQL = '/data/store/virtuoso7.1/bin/isql 20711 dba dba'
ISQL_OPT = 'VERBOSE=OFF BANNER=OFF PROMPT=OFF ECHO=OFF BLOBS=ON ERRORS=stderr'
TOGO_DIR = '/data/store/rdf/togogenome'
BASE_DIR = "#{TOGO_DIR}/bin/text_search"
QUERY_DIR = "#{BASE_DIR}/sparql/organism"
PREPARE_DIR = "#{TOGO_DIR}/text_search/current/prepare/organism"
OUTPUT_DIR = "#{TOGO_DIR}/text_search/current/organism"
OUTPUT_SOLR_DIR = "#{OUTPUT_DIR}/solr"

#query name
GENOME_CROSS_REFERENCES = 'genome_cross_references'
ORGANISM_CROSS_REFERENCES = 'organism_cross_references'
ORGANISM_NAMES = 'organism_names'
ORGANISM_PHENOTYPE = 'organism_phenotype'
ORGANISM_CULTURE_COLLECTIONS = 'organism_culture_collections'
ORGANISM_PATHOGEN_INFORMATION = 'organism_pathogen_information'
ORGANISM_MEDIUM_INFORMATION = 'organism_medium_information'
ORGANISM_MEDIUM_INFORMATION_INGREDIENT = 'organism_medium_information_ingredient'

@metadata = JSON.parse(File.read("#{BASE_DIR}/organism.json"))

def query(query_name)
  STDERR.puts "Start: query [#{query_name}]"
  FileUtils.mkdir_p("#{PREPARE_DIR}/text")
  query_file = "#{QUERY_DIR}/#{query_name}.rq"
  output_file = "#{PREPARE_DIR}/text/#{query_name}.txt"
  system(%Q[#{ISQL} #{ISQL_OPT} < #{query_file} > #{output_file}])
  STDERR.puts "End: query [#{query_name}]"
end

def to_utf(str)
  str.force_encoding('UTF-8')
end

def create_json(stanza_name,query_names)
  STDERR.puts "Start: create json [#{stanza_name}]"
  result = {}
  #load each query result file
  query_names.each do |query_name|
    input_file = "#{PREPARE_DIR}/text/#{query_name}.txt"
    File.open("#{input_file}") do |f|
      while line  = f.gets
        # convert a line to hash object
        tax_text_data = taxonomy_obj_mapping(line, query_name)
        tax_id = tax_text_data.keys.first
        if result[tax_id] == nil
          result[tax_id] = tax_text_data[tax_id]
        else # current tax_id has already added to hash
          result[tax_id].merge!(tax_text_data[tax_id]) do |key, oldval, newval|
            if key.to_s == 'tax_id' # no re of tax id
              oldval
            else # concat text data
              oldval + ',' + newval
            end
          end
        end
      end
    end
  end

  columns = []
  @metadata["stanzas"].map do |stanza|
    if stanza_name == stanza["stanza_name"]
      stanza["queries"].each do |query|
        query["columns"].each do |column|
          columns.push(column["columns_name"])
        end
      end
    end
  end
  columns = columns.uniq

  #output json file
  FileUtils.mkdir_p("#{OUTPUT_DIR}")
  FileUtils.mkdir_p("#{OUTPUT_SOLR_DIR}")
  output_file  = "#{OUTPUT_DIR}/#{stanza_name}.jsonld"
  output_solr_file  = "#{OUTPUT_SOLR_DIR}/#{stanza_name}.json"
  solr_index_file = File.open("#{output_solr_file}", 'w')
  File.open("#{output_file}", 'w') do |file|
    file.puts '{'
    file.puts '"@context" :'
    file.puts JSON.pretty_generate(get_context_hash(stanza_name, columns))
    file.puts ','
    file.puts '"@graph" :'
    file.puts '['
    solr_index_file.puts '['
    comma = ','
    cnt = 0

    result.each do |tax_id, tax_info|
      if cnt == result.size - 1
        comma = ''
      end
      #hash = {"@id" => tax_id, "values" => tax_info}
      hash = {"@id" => "http://togogenome.org/organism/#{tax_id}"}.merge(tax_info)  
      file.puts JSON.pretty_generate(hash) + comma
      solr_index_file.puts JSON.pretty_generate(hash) + comma
      cnt += 1
    end
    file.puts ']'
    solr_index_file.puts ']'
    file.puts '}'
  end
  solr_index_file.close()
  STDERR.puts "End: create json [#{stanza_name}]"
end

def get_context_hash(stanza_name, column_names)
  base_url = "http://togogenome.org/#{stanza_name}"

  hash = {}
  column_names.each do |column_name|
    hash[column_name] = "#{base_url}/#{column_name}"
  end  
  hash
end

def taxonomy_obj_mapping(line, query_name)
  return line.start_with?('http://identifiers.org/taxonomy/') unless
  line.force_encoding('UTF-8')
  line = line.encode("UTF-16BE", "UTF-8", :invalid => :replace, :undef => :replace, :replace => '?').encode("UTF-8")
  columns = line.split('^@')
  tax_no = columns[0].strip.gsub('http://identifiers.org/taxonomy/','')

  case query_name
  when GENOME_CROSS_REFERENCES 
    values = { :tax_id => to_utf(tax_no),
               :refseq_definitions => to_utf(columns[1].strip),
               :bioproject_ids => to_utf(columns[2].strip),
               :refseq_ids => to_utf(columns[3].strip),
               :xref_ids => to_utf(columns[4].strip)}
  when ORGANISM_CROSS_REFERENCES
    values = { :tax_id => to_utf(tax_no),
               :gold_ids => to_utf(columns[1].strip)}
  when ORGANISM_NAMES
    values = { :tax_id => to_utf(tax_no),
               :name => to_utf(columns[1].strip),
               :synonyms => to_utf(columns[2].strip)}
  when ORGANISM_PHENOTYPE
    values = { :tax_id => to_utf(tax_no),
               :phenotype_values => to_utf(columns[1].strip)}
  when ORGANISM_CULTURE_COLLECTIONS 
    values = { :tax_id => to_utf(tax_no),
               :strain_numbers => to_utf(columns[1].strip),
               :strain_names => to_utf(columns[2].strip),
               :isolations => to_utf(columns[3].strip),
               :meo_labels => to_utf(columns[4].strip),
               :applications => to_utf(columns[5].strip),
               :up_alternative_names => to_utf(columns[6].strip)}
  when ORGANISM_PATHOGEN_INFORMATION
    values = { :tax_id => to_utf(tax_no),
               :organismNameSet => to_utf(columns[1].strip),
               :diseaseNameSet => to_utf(columns[2].strip),
               :infectiousTypes => to_utf(columns[3].strip),
               :strainTypes => to_utf(columns[4].strip)}
  when ORGANISM_MEDIUM_INFORMATION
    values = { :tax_id => to_utf(tax_no),
               :medium_ids => to_utf(columns[1].strip),
               :medium_type_labels => to_utf(columns[2].strip),
               :medium_names => to_utf(columns[3].strip)}
  when ORGANISM_MEDIUM_INFORMATION_INGREDIENT
    values = { :tax_id => to_utf(tax_no),
               :class_labels => to_utf(columns[1].strip),
               :ingredient_labels => to_utf(columns[2].strip)}
  end
  {tax_no => values}
end

#@metadata["stanzas"].each do |stanza|
#   puts "stanza_name:" + stanza["stanza_name"]
#   stanza["queries"].each do |query|
#     puts " query_name:" + query["query_name"]
     #if (stanza["stanza_name"] == "organism_cross_references" && query["query_name"] == "genome_cross_references")
     #if query["query_name"] != "genome_cross_references"
      # query(query["query_name"])
     #end
#   end
#end

#query("genome_cross_references2")
#query(GENOME_CROSS_REFERENCES)
#create_json('genome_cross_references', [GENOME_CROSS_REFERENCES])

#query(ORGANISM_CROSS_REFERENCES)
#query_names = [GENOME_CROSS_REFERENCES, ORGANISM_CROSS_REFERENCES]
#create_json('organism_cross_references', query_names)

#query(ORGANISM_NAMES)
#create_json('organism_names', [ORGANISM_NAMES])

#query(ORGANISM_PHENOTYPE)
#create_json('organism_phenotype', [ORGANISM_PHENOTYPE])

#query(ORGANISM_CULTURE_COLLECTIONS)
#create_json('organism_culture_collections', [ORGANISM_CULTURE_COLLECTIONS])

#query(ORGANISM_PATHOGEN_INFORMATION)
#create_json('organism_pathogen_information', [ORGANISM_PATHOGEN_INFORMATION])

#query(ORGANISM_MEDIUM_INFORMATION)
#query(ORGANISM_MEDIUM_INFORMATION_INGREDIENT)
#query_names = [ORGANISM_MEDIUM_INFORMATION, ORGANISM_MEDIUM_INFORMATION_INGREDIENT]
#create_json('organism_medium_information', query_names)
